-- This file is part of KDevelop.
-- Copyright (C) 2002-2005 Roberto Raggi <roberto@kdevelop.org>
-- Copyright (C) 2006 Adam Treat <treat@kde.org>
-- Copyright (c) 2006 Jakob Petsovits <jpetso@gmx.at>
--
-- This grammar is free software; you can redistribute it and/or
-- modify it under the terms of the GNU Library General Public
-- License as published by the Free Software Foundation; either
-- version 2 of the License, or (at your option) any later version.
--
-- This grammar is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-- Lesser General Public License for more details.
--
-- You should have received a copy of the GNU Library General Public License
-- along with this library; see the file COPYING.LIB.  If not, write to
-- the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
-- Boston, MA 02110-1301, USA.


------------------------------------------------------------
-- Code model for C++
------------------------------------------------------------

[:
#include "codedisplay.h"

#include <QtCore/QString>
#include <QtCore/QStringList>
:]


CodeModel
{
  root = globalNamespace: Namespace;

  constructor
  [:
    _M_globalNamespace = create<ITEM(Namespace)>();
    _M_globalNamespace->setName(QString::null);
  :]

  destructor
  [:
    // FIXME jpetso: don't we need "delete _M_globalNamespace;" here?
  :]

  public declaration
  [:
    enum AccessPolicy
    {
      Public,
      Protected,
      Private
    };
    enum FunctionType
    {
      Normal,
      Signal,
      Slot
    };
    enum ClassType
    {
      Class,
      Struct,
      Union
    };

    ITEM(Code) findItem(const QStringList &qualifiedName, ITEM(Code) scope) const;
  :]

  implementation
  [:
    ITEM(Code) CLASS::findItem(const QStringList &qualifiedName, ITEM(Code) scope) const
    {
      for (int i=0; i<qualifiedName.size(); ++i) {
        // ### Extend to look for members etc too.
        const QString &name = qualifiedName.at(i);
        if (ITEM(Namespace) ns = model_dynamic_cast<ITEM(Namespace)>(scope))
          {
            ITEM(Namespace) tmp_ns = ns->findNamespace(name);
            if (tmp_ns) {
              scope = tmp_ns;
              continue;
            }
          }
        if (ITEM(Scope) ss = model_dynamic_cast<ITEM(Scope)>(scope))
          {
            if (ITEM(Class) cs = ss->findClass(name))
              {
                scope = cs;
              }
            else if (ITEM(Enum) es = ss->findEnum(name))
              {
                Q_ASSERT(i == qualifiedName.size() - 1);
                return es->toItem();
              }
          }
      }
      return scope;
    }
  :]
}

TypeInfo
{
  qualifiedName: QStringList;
  isConstant:    bool;
  isReference:   bool;
  indirections:  int;

  public declaration
  [:
    bool operator==(const TypeInfo &other);
    bool operator!=(const TypeInfo &other) { return !(*this==other); }

    // ### arrays and templates??

    QString toString() const;
  :]

  implementation
  [:
    QString CLASS::toString() const
    {
      QString tmp;
      if (isConstant())
        tmp += "const ";
      tmp += _M_qualifiedName.join("::");
      if (indirections())
        tmp += QString(indirections(), QLatin1Char('*'));
      if (isReference())
        tmp += QLatin1Char('&');
      return tmp;
    }

    bool CLASS::operator==(const TypeInfo &other)
    {
      return isConstant() == other.isConstant()
        && isReference() == other.isReference()
        && indirections() == other.indirections()
        && qualifiedName() == other.qualifiedName();
    }
  :]
}

Code
{
  name:     QString;
  scope:    QStringList;
  fileName: QString;

  public declaration
  [:
    QStringList qualifiedName() const;

    ///TODO These functions should be cached upon initialization
    QString display() const;
    QIcon decoration() const;
    QString toolTip() const;
    QString whatsThis() const;
  :]

  implementation
  [:
    QStringList CLASS::qualifiedName() const
    {
      QStringList q = scope();

      if (!name().isEmpty())
        q += name();

      return q;
    }

    ///TODO These functions should be cached upon initialization
    QString CLASS::display() const
    {
      return CodeDisplay::display( const_cast<const CLASS*>( this ) );
    }
    QIcon CLASS::decoration() const
    {
      return CodeDisplay::decoration( const_cast<const CLASS*>( this ) );
    }
    QString CLASS::toolTip() const
    {
      return CodeDisplay::toolTip( const_cast<const CLASS*>( this ) );
    }
    QString CLASS::whatsThis() const
    {
      return CodeDisplay::whatsThis( const_cast<const CLASS*>( this ) );
    }
  :]
}

Scope: Code
{
  #class:        Class     { hashed(name) };
  #enum:         Enum      { hashed(name) };
  #functionDefinition: FunctionDefinition
    { multihashed(name),
      unique [: !existingItem->isSimilar( model_static_cast<ITEM(Code)>(item) ) :]
    };
  #function:     Function
    { multihashed(name),
      unique [: !existingItem->isSimilar( model_static_cast<ITEM(Code)>(item) ) :]
    };
  #typeAlias:    TypeAlias { hashed(name) };
  #variable:     Variable  { hashed(name) };
  #template:     Template  { multihashed(name) };

  public declaration
  [:
    ITEM(Function) declaredFunction(ITEM(Function) item);
  :]

  implementation
  [:
    ITEM(Function) CLASS::declaredFunction(ITEM(Function) item)
    {
      LIST(Function) functionList = findFunctions(item->name());

      foreach (ITEM(Function) fun, functionList)
        {
          if (fun->isSimilar(model_static_cast<ITEM(Code)>(item),false))
            return fun;
        }

      return ITEM(Function)();
    }
 :]
}

Class: Scope
{
  baseClasses:   QStringList;
  classType:     CodeModel::ClassType { init[: CodeModel::Class :] };

  public declaration
  [:
    void addBaseClass(const QString &baseClass);
    void removeBaseClass(const QString &baseClass);

    bool extendsClass(const QString &name) const;
  :]
}

Namespace: Scope
{
  #namespace:    Namespace { hashed(name) };
}

File: Namespace
{
}

Argument: Code
{
  type:          TypeInfo;
  defaultValue:  bool { init[: false :] };
}

Member: Code
{
  isConstant:    bool { init[: false :] };
  isVolatile:    bool { init[: false :] };
  isStatic:      bool { init[: false :] };
  isAuto:        bool { init[: false :] };
  isFriend:      bool { init[: false :] };
  isRegister:    bool { init[: false :] };
  isExtern:      bool { init[: false :] };
  isMutable:     bool { init[: false :] };
  accessPolicy:  CodeModel::AccessPolicy { init[: CodeModel::Public :] };
  type:          TypeInfo;
}

Function: Member
{
  #argument:     Argument;
  functionType:  CodeModel::FunctionType { init[: CodeModel::Normal :] };
  isVirtual:     bool { init[: false :] };
  isInline:      bool { init[: false :] };
  isExplicit:    bool { init[: false :] };
  isAbstract:    bool { init[: false :] };

  public declaration
  [:
    bool isConstructor() const;
    bool isDestructor() const;

    bool isSimilar(KDevCodeItem *other, bool strict = true) const;
  :]

  private declaration
  [:
    mutable bool _M_isConstructor;
    mutable bool _M_isDestructor;
  :]

  implementation
  [:
    bool CLASS::isConstructor() const
    {
      ///TODO cache this information upon initialization
      return scope().isEmpty() ? false : scope().last() == name();
    }
    bool CLASS::isDestructor() const
    {
      ///TODO cache this information upon initialization
      return name().startsWith('~');
    }

    bool CLASS::isSimilar(KDevCodeItem *other, bool strict ) const
    {
      if (!BASECLASS::isSimilar(other,strict))
        return false;

      ITEM(Function) func = dynamic_cast<CLASS*>(other);

      if (isConstant() != func->isConstant())
        return false;

      if (arguments().count() != func->arguments().count())
        return false;

      for (int i=0; i<arguments().count(); ++i)
        {
          ITEM(Argument) arg1 = arguments().at(i);
          ITEM(Argument) arg2 = arguments().at(i);

          if (arg1->type() != arg2->type())
            return false;
        }

      return true;
    }
  :]
}

FunctionDefinition: Function
{
}

Variable: Member
{
}

TypeAlias: Code
{
  type:         TypeInfo;
}

Enum: Code
{
  accessPolicy: CodeModel::AccessPolicy { init[: CodeModel::Public :] };
  #enumerator:  Enumerator;
}

Enumerator: Code
{
  value:        QString;
}

TemplateParameter: Code
{
  type:         TypeInfo;
  defaultValue: bool { init[: false :] };
}

Template: Code
{
  #parameter:   TemplateParameter;
  declaration:  Code;
}
